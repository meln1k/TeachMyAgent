<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TeachMyAgent.environments.envs.parametric_continuous_stump_tracks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://github.com/flowersteam/TeachMyAgent/blob/gh-pages/images/favicon-96x96.png?raw=true" />
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TeachMyAgent.environments.envs.parametric_continuous_stump_tracks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Parametric Walker continuous environment
#
# Reward is given for moving forward, total 300+ points up to the far end. If the robot falls,
# it gets -100. Applying motor torque costs a small amount of points, more optimal agent
# will get better score.
#
# State consists of hull angle speed, angular velocity, horizontal speed, vertical speed,
# position of joints and joints angular speed, legs contact with ground, and 10 lidar
# rangefinder measurements. There&#39;s no coordinates
# in the state vector.
#
# Initially Created by Oleg Klimov. Licensed on the same terms as the rest of OpenAI Gym.
# Modified by Rémy Portelas and licensed under TeachMyAgent/teachers/LICENSES/ALP-GMM
# Modified Clément Romac

#region Imports

import numpy as np
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
import gym
from gym import spaces
from gym.utils import colorize, seeding, EzPickle
import math

from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData

#endregion

#region Utils


class ContactDetector(contactListener):
    &#39;&#39;&#39;
        Custom contact detector.
    &#39;&#39;&#39;
    def __init__(self, env):
        contactListener.__init__(self)
        self.env = env
    def BeginContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            Sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        &#39;&#39;&#39;
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = True
                if body.userData.is_contact_critical:
                    self.env.head_contact = True

    def EndContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact ends.

            Sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        &#39;&#39;&#39;
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = False

def Rotate2D(pts,cnt,ang=np.pi/4):
    &#39;&#39;&#39;pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian&#39;&#39;&#39;
    m1 = pts-cnt
    m2 = np.array([[np.cos(ang),np.sin(ang)],[-np.sin(ang),np.cos(ang)]])
    return np.dot(m1,m2)+cnt


class LidarCallback(Box2D.b2.rayCastCallback):
    &#39;&#39;&#39;
        Callback function triggered when lidar detects an object.
    &#39;&#39;&#39;
    def __init__(self, agent_mask_filter):
        &#39;&#39;&#39;
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent&#39;s body
        &#39;&#39;&#39;
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
    def ReportFixture(self, fixture, point, normal, fraction):
        &#39;&#39;&#39;
            Triggered when a body is detected by the lidar.

            Returns:
                Distance to object detected.
        &#39;&#39;&#39;
        if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        return fraction

#endregion

#region Constants

FPS    = 50
SCALE  = 30.0   # affects how fast-paced the game is, forces should be adjusted as well
VIEWPORT_W = 600 # Careful, this affects training
VIEWPORT_H = 400 # Careful, this affects training

RENDERING_VIEWER_W = VIEWPORT_W # Only affects rendering, not the policy
RENDERING_VIEWER_H = VIEWPORT_H # Only affects rendering, not the policy

NB_LIDAR = 10 # Number of lidars used by the agent
LIDAR_RANGE   = 160/SCALE

INITIAL_RANDOM = 5

TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200     # in steps
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 10    # in steps
INITIAL_TERRAIN_STARTPAD = 20 # in steps
FRICTION = 2.5

#endregion

class ParametricContinuousStumpTracks(gym.Env, EzPickle):
    &#39;&#39;&#39;
        The Stump Tracks: a procedurally generated Gym environment.
    &#39;&#39;&#39;
    metadata = {
        &#39;render.modes&#39;: [&#39;human&#39;, &#39;rgb_array&#39;],
        &#39;video.frames_per_second&#39; : FPS
    }

    def __init__(self, walker_type, **walker_args):
        &#39;&#39;&#39;
            Creates a Stump Tracks environment with an embodiment.

                walker_type: Embodiment
            :type walker_type: BodiesEnum
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        &#39;&#39;&#39;

        super(ParametricContinuousStumpTracks, self).__init__()

        # Seed env and init Box2D
        self.seed()
        self.viewer = None

        self.world = Box2D.b2World()
        self.terrain = []

        self.prev_shaping = None

        # Create agent
        body_type = BodiesEnum.get_body_type(walker_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, density=1.0, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=True)
        else:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args)

        # Adapt startpad to walker&#39;s width
        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5 &lt;= INITIAL_TERRAIN_STARTPAD else \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        # Set observation / action spaces
        self._generate_walker()  # To get state / action sizes
        agent_action_size = self.walker_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.walker_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    4 +  # head infos
                                    NB_LIDAR))  # lidars infos
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_environment(self, roughness=None, stump_height=None, stump_width=None, stump_rot=None,
                        obstacle_spacing=None, poly_shape=None, stump_seq=None):
        &#39;&#39;&#39;
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                roughness: Input vector controlling the CPPN
                stump_height: Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled
                stump_width: Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled
                stump_rot: Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled
                obstacle_spacing: Spacing between stumps
                poly_shape: Shape of polygon stumps
        &#39;&#39;&#39;
        self.roughness = roughness if roughness else 0
        self.obstacle_spacing = max(0.01, obstacle_spacing) if obstacle_spacing is not None else 8.0
        self.stump_height = [stump_height, 0.1] if stump_height is not None else None
        self.stump_width = stump_width
        self.stump_rot = stump_rot
        self.hexa_shape = poly_shape
        self.stump_seq = stump_seq
        if poly_shape is not None:
            self.hexa_shape = np.interp(poly_shape,[0,4],[0,4]).tolist()
            assert(len(poly_shape) == 12)
            self.hexa_shape = self.hexa_shape[0:12]

    def _destroy(self):
        # if not self.terrain: return
        self.world.contactListener = None
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.walker_body.destroy(self.world)

    def reset(self):
        self._destroy()
        self.world.contactListener_bug_workaround = ContactDetector(self)
        self.world.contactListener = self.world.contactListener_bug_workaround
        self.head_contact = False
        self.prev_shaping = None
        self.scroll = 0.0
        self.lidar_render = 0

        self.generate_game()

        self.drawlist = self.terrain + self.walker_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.walker_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]
        self.episodic_reward = 0

        return self.step(np.array([0] * self.action_space.shape[0]))[0]

    def step(self, action):
        self.walker_body.activate_motors(action)

        self.world.Step(1.0/FPS, 6*30, 2*30)

        head = self.walker_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin(1.5*i/NB_LIDAR)*LIDAR_RANGE,
                pos[1] - math.cos(1.5*i/NB_LIDAR)*LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
        state = [
            head.angle,        # Normal angles up to 0.5 here, but sure more is possible.
            2.0*head.angularVelocity/FPS,
            0.3*vel.x*(VIEWPORT_W/SCALE)/FPS,  # Normalized to get -1..1 range
            0.3*vel.y*(VIEWPORT_H/SCALE)/FPS]

        # add leg-related state
        state.extend(self.walker_body.get_motors_state())

        if self.walker_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.walker_body.get_sensors_state())

        state += [l.fraction for l in self.lidar]

        self.scroll = pos.x - RENDERING_VIEWER_W/SCALE/5

        shaping  = 130*pos[0]/SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (hasattr(self.walker_body, &#34;remove_reward_on_head_angle&#34;) and self.walker_body.remove_reward_on_head_angle):
            shaping -= 5.0*abs(state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.walker_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1) # 80 =&gt; Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        done = False
        if self.head_contact or pos[0] &lt; 0:
            reward = -100
            done   = True
        if pos[0] &gt; (TERRAIN_LENGTH-TERRAIN_END)*TERRAIN_STEP:
            done   = True
        self.episodic_reward += reward
        return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}

    def render(self, mode=&#39;human&#39;, draw_lidars=True):
        #self.scroll = 1
        from gym.envs.classic_control import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll, RENDERING_VIEWER_W/SCALE + self.scroll, 0, RENDERING_VIEWER_H/SCALE)

        self.viewer.draw_polygon( [
            (self.scroll,                  0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, 0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, RENDERING_VIEWER_H/SCALE),
            (self.scroll,                  RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )
        for poly,x1,x2 in self.cloud_poly:
            if x2 &lt; self.scroll/2: continue
            if x1 &gt; self.scroll/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll/2, p[1]) for p in poly], color=(1,1,1))
        for poly, color in self.terrain_poly:
            if poly[1][0] &lt; self.scroll: continue
            if poly[0][0] &gt; self.scroll + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        for obj in self.drawlist:
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=obj.color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        &#39;&#39;&#39;
            Set rendering viewport&#39;s size (i.e. image size).

            Args:
                width: viewport&#39;s width
                height: viewport&#39;s height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment&#39;s viewport size.
        &#39;&#39;&#39;
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height

    def close(self):
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        &#39;&#39;&#39;
            Create fixtures used to generate terrain.
        &#39;&#39;&#39;
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        # Init default hexagon fixture and shape, used only for Hexagon Tracks
        self.fd_default_hexagon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )
        self.default_hexagon = [(-0.5, 0), (-0.5, 0.25), (-0.25, 0.5), (0.25, 0.5), (0.5, 0.25), (0.5, 0)]

    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        &#39;&#39;&#39;
            Generate the task (i.e. terrain + embodiment).
        &#39;&#39;&#39;
        self._generate_terrain()
        self._generate_clouds()
        self._generate_walker()

    def _generate_terrain(self):
        GRASS, STUMP, HEXA = 0, None, None
        cpt=1
        if self.stump_height:
            STUMP = cpt
            cpt += 1
        if self.hexa_shape:
            HEXA = cpt
            cpt += 1
        if self.stump_seq is not None:
            SEQ = cpt
            cpt += 1
        _STATES_ = cpt

        state = self.np_random.randint(1, _STATES_)
        velocity = 0.0
        y = TERRAIN_HEIGHT
        self.terrain = []
        self.terrain_x = []
        self.terrain_y = []
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP

        # Add startpad
        max_startpad_x = self.TERRAIN_STARTPAD * TERRAIN_STEP
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        x += max_startpad_x
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        oneshot = True

        # Generation of terrain
        while x &lt; max_x:
            self.terrain_x.append(x)

            if state==GRASS and not oneshot:
                velocity = 0.8*velocity + 0.01*np.sign(TERRAIN_HEIGHT - y)
                if x &gt; max_startpad_x: velocity += self.np_random.uniform(-self.roughness, self.roughness)/SCALE
                y += velocity
                x += self.obstacle_spacing

            elif state==STUMP and oneshot:
                stump_height = max(0.05, self.np_random.normal(self.stump_height[0], self.stump_height[1]))
                stump_width = TERRAIN_STEP
                if self.stump_width is not None:
                    stump_width *= max(0.05, np.random.normal(self.stump_width[0], self.stump_width[1]))
                poly = [
                    (x, y),
                    (x+stump_width, y),
                    (x+stump_width, y+stump_height * TERRAIN_STEP),
                    (x,y+stump_height * TERRAIN_STEP),
                    ]
                x += stump_width
                if self.stump_rot is not None:
                    anchor = (np.array(poly[0]) + np.array(poly[1]))/2
                    rotation = np.clip(self.np_random.normal(self.stump_rot[0], self.stump_rot[1]),0,2*np.pi)
                    poly = Rotate2D(np.array(poly), anchor, rotation).tolist()
                self.fd_polygon.shape.vertices=poly
                t = self.world.CreateStaticBody(
                    fixtures = self.fd_polygon,
                    userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
                t.color1, t.color2 = (1,1,1), (0.6,0.6,0.6)
                self.terrain.append(t)
            elif state==HEXA and oneshot:
                # first point do not move
                poly = []
                delta_pos = []
                for i in range(0,len(self.hexa_shape),2):
                    delta_pos.append(tuple(np.random.normal(self.hexa_shape[i:i+2],0.1)))
                for i,(b,d) in enumerate(zip(self.default_hexagon, delta_pos)):
                    if i != 0 and i != (len(self.default_hexagon)-1):
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP) + (d[1]*TERRAIN_STEP)))
                    else:
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP)))
                x += 1
                self.fd_default_hexagon.shape.vertices = poly
                t = self.world.CreateStaticBody(
                    fixtures=self.fd_default_hexagon)
                t.color1, t.color2 = (1.0, np.clip(delta_pos[0][1]/3,0,1), np.clip(delta_pos[-1][1]/3,0,1)), (0.6, 0.6, 0.6)
                self.terrain.append(t)

            elif state==SEQ and oneshot:
                for height, width in zip(self.stump_seq[0::2], self.stump_seq[1::2]):
                    stump_height = max(0.05, self.np_random.normal(height, 0.1))
                    stump_width = max(0.05, self.np_random.normal(width, 0.1))
                    poly = [
                        (x, y),
                        (x + stump_width, y),
                        (x + stump_width, y + stump_height * TERRAIN_STEP),
                        (x, y + stump_height * TERRAIN_STEP),
                    ]
                    x += stump_width
                    self.fd_polygon.shape.vertices = poly
                    t = self.world.CreateStaticBody(
                        fixtures=self.fd_polygon,
                        userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
                    t.color1, t.color2 = (1, 1, 1), (0.6, 0.6, 0.6)
                    self.terrain.append(t)

            oneshot = False
            self.terrain_y.append(y)
            if state==GRASS:
                state = self.np_random.randint(1, _STATES_)
                oneshot = True
            else:
                state = GRASS
                oneshot = False

        # Draw terrain
        self.terrain_poly = []
        assert len(self.terrain_x) == len(self.terrain_y)
        for i in range(len(self.terrain_x)-1):
            poly = [
                (self.terrain_x[i],   self.terrain_y[i]),
                (self.terrain_x[i+1], self.terrain_y[i+1])
                ]
            self.fd_edge.shape.vertices=poly
            t = self.world.CreateStaticBody(
                fixtures = self.fd_edge,
                userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [ (poly[1][0], 0), (poly[0][0], 0) ]
            self.terrain_poly.append( (poly, color) )
        self.terrain.reverse()

    def _generate_clouds(self):
        # Sorry for the clouds, couldn&#39;t resist
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_walker(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        if hasattr(self.walker_body, &#34;old_morphology&#34;) and self.walker_body.old_morphology:
            init_y = TERRAIN_HEIGHT + 2 * self.walker_body.LEG_H
        else:
            init_y = TERRAIN_HEIGHT + self.walker_body.AGENT_CENTER_HEIGHT

        self.walker_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )

    #endregion</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.Rotate2D"><code class="name flex">
<span>def <span class="ident">Rotate2D</span></span>(<span>pts, cnt, ang=0.7853981633974483)</span>
</code></dt>
<dd>
<div class="desc"><p>pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rotate2D(pts,cnt,ang=np.pi/4):
    &#39;&#39;&#39;pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian&#39;&#39;&#39;
    m1 = pts-cnt
    m2 = np.array([[np.cos(ang),np.sin(ang)],[-np.sin(ang),np.cos(ang)]])
    return np.dot(m1,m2)+cnt</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector"><code class="flex name class">
<span>class <span class="ident">ContactDetector</span></span>
<span>(</span><span>env)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom contact detector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContactDetector(contactListener):
    &#39;&#39;&#39;
        Custom contact detector.
    &#39;&#39;&#39;
    def __init__(self, env):
        contactListener.__init__(self)
        self.env = env
    def BeginContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            Sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        &#39;&#39;&#39;
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = True
                if body.userData.is_contact_critical:
                    self.env.head_contact = True

    def EndContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact ends.

            Sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        &#39;&#39;&#39;
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>Box2D.Box2D.b2ContactListener</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.BeginContact"><code class="name flex">
<span>def <span class="ident">BeginContact</span></span>(<span>self, contact)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when contact is detected.</p>
<p>Checks userData of each of the two fixtures colliding.
Sets <code>userData.has_contact</code> to True on the body if <code>body.userData.check_contact == True</code>.
If <code>userData.is_contact_critical == True</code>, <code>env.critical_contact</code> is set to True, stopping the episode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BeginContact(self, contact):
    &#39;&#39;&#39;
        Triggered when contact is detected.

        Checks userData of each of the two fixtures colliding.
        Sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
        If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
    &#39;&#39;&#39;
    for body in [contact.fixtureA.body, contact.fixtureB.body]:
        if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
            body.userData.has_contact = True
            if body.userData.is_contact_critical:
                self.env.head_contact = True</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.EndContact"><code class="name flex">
<span>def <span class="ident">EndContact</span></span>(<span>self, contact)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when contact ends.</p>
<p>Sets <code>userData.has_contact</code> to False on the body if <code>body.userData.check_contact == True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndContact(self, contact):
    &#39;&#39;&#39;
        Triggered when contact ends.

        Sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
    &#39;&#39;&#39;
    for body in [contact.fixtureA.body, contact.fixtureB.body]:
        if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
            body.userData.has_contact = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback"><code class="flex name class">
<span>class <span class="ident">LidarCallback</span></span>
<span>(</span><span>agent_mask_filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function triggered when lidar detects an object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent_mask_filter</code></strong></dt>
<dd>Mask filter used to avoid detecting collisions with the agent's body</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LidarCallback(Box2D.b2.rayCastCallback):
    &#39;&#39;&#39;
        Callback function triggered when lidar detects an object.
    &#39;&#39;&#39;
    def __init__(self, agent_mask_filter):
        &#39;&#39;&#39;
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent&#39;s body
        &#39;&#39;&#39;
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
    def ReportFixture(self, fixture, point, normal, fraction):
        &#39;&#39;&#39;
            Triggered when a body is detected by the lidar.

            Returns:
                Distance to object detected.
        &#39;&#39;&#39;
        if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        return fraction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>Box2D.Box2D.b2RayCastCallback</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback.ReportFixture"><code class="name flex">
<span>def <span class="ident">ReportFixture</span></span>(<span>self, fixture, point, normal, fraction)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when a body is detected by the lidar.</p>
<h2 id="returns">Returns</h2>
<p>Distance to object detected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReportFixture(self, fixture, point, normal, fraction):
    &#39;&#39;&#39;
        Triggered when a body is detected by the lidar.

        Returns:
            Distance to object detected.
    &#39;&#39;&#39;
    if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
        return -1
    self.p2 = point
    self.fraction = fraction
    return fraction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks"><code class="flex name class">
<span>class <span class="ident">ParametricContinuousStumpTracks</span></span>
<span>(</span><span>walker_type, **walker_args)</span>
</code></dt>
<dd>
<div class="desc"><p>The Stump Tracks: a procedurally generated Gym environment.</p>
<p>Creates a Stump Tracks environment with an embodiment.</p>
<pre><code>walker_type: Embodiment
</code></pre>
<p>:type walker_type: BodiesEnum
walker_args: kwargs controlling the agent (e.g. number of body for a millipede)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParametricContinuousStumpTracks(gym.Env, EzPickle):
    &#39;&#39;&#39;
        The Stump Tracks: a procedurally generated Gym environment.
    &#39;&#39;&#39;
    metadata = {
        &#39;render.modes&#39;: [&#39;human&#39;, &#39;rgb_array&#39;],
        &#39;video.frames_per_second&#39; : FPS
    }

    def __init__(self, walker_type, **walker_args):
        &#39;&#39;&#39;
            Creates a Stump Tracks environment with an embodiment.

                walker_type: Embodiment
            :type walker_type: BodiesEnum
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        &#39;&#39;&#39;

        super(ParametricContinuousStumpTracks, self).__init__()

        # Seed env and init Box2D
        self.seed()
        self.viewer = None

        self.world = Box2D.b2World()
        self.terrain = []

        self.prev_shaping = None

        # Create agent
        body_type = BodiesEnum.get_body_type(walker_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, density=1.0, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=True)
        else:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args)

        # Adapt startpad to walker&#39;s width
        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5 &lt;= INITIAL_TERRAIN_STARTPAD else \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        # Set observation / action spaces
        self._generate_walker()  # To get state / action sizes
        agent_action_size = self.walker_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.walker_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    4 +  # head infos
                                    NB_LIDAR))  # lidars infos
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_environment(self, roughness=None, stump_height=None, stump_width=None, stump_rot=None,
                        obstacle_spacing=None, poly_shape=None, stump_seq=None):
        &#39;&#39;&#39;
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                roughness: Input vector controlling the CPPN
                stump_height: Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled
                stump_width: Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled
                stump_rot: Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled
                obstacle_spacing: Spacing between stumps
                poly_shape: Shape of polygon stumps
        &#39;&#39;&#39;
        self.roughness = roughness if roughness else 0
        self.obstacle_spacing = max(0.01, obstacle_spacing) if obstacle_spacing is not None else 8.0
        self.stump_height = [stump_height, 0.1] if stump_height is not None else None
        self.stump_width = stump_width
        self.stump_rot = stump_rot
        self.hexa_shape = poly_shape
        self.stump_seq = stump_seq
        if poly_shape is not None:
            self.hexa_shape = np.interp(poly_shape,[0,4],[0,4]).tolist()
            assert(len(poly_shape) == 12)
            self.hexa_shape = self.hexa_shape[0:12]

    def _destroy(self):
        # if not self.terrain: return
        self.world.contactListener = None
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.walker_body.destroy(self.world)

    def reset(self):
        self._destroy()
        self.world.contactListener_bug_workaround = ContactDetector(self)
        self.world.contactListener = self.world.contactListener_bug_workaround
        self.head_contact = False
        self.prev_shaping = None
        self.scroll = 0.0
        self.lidar_render = 0

        self.generate_game()

        self.drawlist = self.terrain + self.walker_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.walker_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]
        self.episodic_reward = 0

        return self.step(np.array([0] * self.action_space.shape[0]))[0]

    def step(self, action):
        self.walker_body.activate_motors(action)

        self.world.Step(1.0/FPS, 6*30, 2*30)

        head = self.walker_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin(1.5*i/NB_LIDAR)*LIDAR_RANGE,
                pos[1] - math.cos(1.5*i/NB_LIDAR)*LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
        state = [
            head.angle,        # Normal angles up to 0.5 here, but sure more is possible.
            2.0*head.angularVelocity/FPS,
            0.3*vel.x*(VIEWPORT_W/SCALE)/FPS,  # Normalized to get -1..1 range
            0.3*vel.y*(VIEWPORT_H/SCALE)/FPS]

        # add leg-related state
        state.extend(self.walker_body.get_motors_state())

        if self.walker_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.walker_body.get_sensors_state())

        state += [l.fraction for l in self.lidar]

        self.scroll = pos.x - RENDERING_VIEWER_W/SCALE/5

        shaping  = 130*pos[0]/SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (hasattr(self.walker_body, &#34;remove_reward_on_head_angle&#34;) and self.walker_body.remove_reward_on_head_angle):
            shaping -= 5.0*abs(state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.walker_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1) # 80 =&gt; Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        done = False
        if self.head_contact or pos[0] &lt; 0:
            reward = -100
            done   = True
        if pos[0] &gt; (TERRAIN_LENGTH-TERRAIN_END)*TERRAIN_STEP:
            done   = True
        self.episodic_reward += reward
        return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}

    def render(self, mode=&#39;human&#39;, draw_lidars=True):
        #self.scroll = 1
        from gym.envs.classic_control import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll, RENDERING_VIEWER_W/SCALE + self.scroll, 0, RENDERING_VIEWER_H/SCALE)

        self.viewer.draw_polygon( [
            (self.scroll,                  0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, 0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, RENDERING_VIEWER_H/SCALE),
            (self.scroll,                  RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )
        for poly,x1,x2 in self.cloud_poly:
            if x2 &lt; self.scroll/2: continue
            if x1 &gt; self.scroll/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll/2, p[1]) for p in poly], color=(1,1,1))
        for poly, color in self.terrain_poly:
            if poly[1][0] &lt; self.scroll: continue
            if poly[0][0] &gt; self.scroll + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        for obj in self.drawlist:
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=obj.color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        &#39;&#39;&#39;
            Set rendering viewport&#39;s size (i.e. image size).

            Args:
                width: viewport&#39;s width
                height: viewport&#39;s height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment&#39;s viewport size.
        &#39;&#39;&#39;
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height

    def close(self):
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        &#39;&#39;&#39;
            Create fixtures used to generate terrain.
        &#39;&#39;&#39;
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        # Init default hexagon fixture and shape, used only for Hexagon Tracks
        self.fd_default_hexagon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )
        self.default_hexagon = [(-0.5, 0), (-0.5, 0.25), (-0.25, 0.5), (0.25, 0.5), (0.5, 0.25), (0.5, 0)]

    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        &#39;&#39;&#39;
            Generate the task (i.e. terrain + embodiment).
        &#39;&#39;&#39;
        self._generate_terrain()
        self._generate_clouds()
        self._generate_walker()

    def _generate_terrain(self):
        GRASS, STUMP, HEXA = 0, None, None
        cpt=1
        if self.stump_height:
            STUMP = cpt
            cpt += 1
        if self.hexa_shape:
            HEXA = cpt
            cpt += 1
        if self.stump_seq is not None:
            SEQ = cpt
            cpt += 1
        _STATES_ = cpt

        state = self.np_random.randint(1, _STATES_)
        velocity = 0.0
        y = TERRAIN_HEIGHT
        self.terrain = []
        self.terrain_x = []
        self.terrain_y = []
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP

        # Add startpad
        max_startpad_x = self.TERRAIN_STARTPAD * TERRAIN_STEP
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        x += max_startpad_x
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        oneshot = True

        # Generation of terrain
        while x &lt; max_x:
            self.terrain_x.append(x)

            if state==GRASS and not oneshot:
                velocity = 0.8*velocity + 0.01*np.sign(TERRAIN_HEIGHT - y)
                if x &gt; max_startpad_x: velocity += self.np_random.uniform(-self.roughness, self.roughness)/SCALE
                y += velocity
                x += self.obstacle_spacing

            elif state==STUMP and oneshot:
                stump_height = max(0.05, self.np_random.normal(self.stump_height[0], self.stump_height[1]))
                stump_width = TERRAIN_STEP
                if self.stump_width is not None:
                    stump_width *= max(0.05, np.random.normal(self.stump_width[0], self.stump_width[1]))
                poly = [
                    (x, y),
                    (x+stump_width, y),
                    (x+stump_width, y+stump_height * TERRAIN_STEP),
                    (x,y+stump_height * TERRAIN_STEP),
                    ]
                x += stump_width
                if self.stump_rot is not None:
                    anchor = (np.array(poly[0]) + np.array(poly[1]))/2
                    rotation = np.clip(self.np_random.normal(self.stump_rot[0], self.stump_rot[1]),0,2*np.pi)
                    poly = Rotate2D(np.array(poly), anchor, rotation).tolist()
                self.fd_polygon.shape.vertices=poly
                t = self.world.CreateStaticBody(
                    fixtures = self.fd_polygon,
                    userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
                t.color1, t.color2 = (1,1,1), (0.6,0.6,0.6)
                self.terrain.append(t)
            elif state==HEXA and oneshot:
                # first point do not move
                poly = []
                delta_pos = []
                for i in range(0,len(self.hexa_shape),2):
                    delta_pos.append(tuple(np.random.normal(self.hexa_shape[i:i+2],0.1)))
                for i,(b,d) in enumerate(zip(self.default_hexagon, delta_pos)):
                    if i != 0 and i != (len(self.default_hexagon)-1):
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP) + (d[1]*TERRAIN_STEP)))
                    else:
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP)))
                x += 1
                self.fd_default_hexagon.shape.vertices = poly
                t = self.world.CreateStaticBody(
                    fixtures=self.fd_default_hexagon)
                t.color1, t.color2 = (1.0, np.clip(delta_pos[0][1]/3,0,1), np.clip(delta_pos[-1][1]/3,0,1)), (0.6, 0.6, 0.6)
                self.terrain.append(t)

            elif state==SEQ and oneshot:
                for height, width in zip(self.stump_seq[0::2], self.stump_seq[1::2]):
                    stump_height = max(0.05, self.np_random.normal(height, 0.1))
                    stump_width = max(0.05, self.np_random.normal(width, 0.1))
                    poly = [
                        (x, y),
                        (x + stump_width, y),
                        (x + stump_width, y + stump_height * TERRAIN_STEP),
                        (x, y + stump_height * TERRAIN_STEP),
                    ]
                    x += stump_width
                    self.fd_polygon.shape.vertices = poly
                    t = self.world.CreateStaticBody(
                        fixtures=self.fd_polygon,
                        userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
                    t.color1, t.color2 = (1, 1, 1), (0.6, 0.6, 0.6)
                    self.terrain.append(t)

            oneshot = False
            self.terrain_y.append(y)
            if state==GRASS:
                state = self.np_random.randint(1, _STATES_)
                oneshot = True
            else:
                state = GRASS
                oneshot = False

        # Draw terrain
        self.terrain_poly = []
        assert len(self.terrain_x) == len(self.terrain_y)
        for i in range(len(self.terrain_x)-1):
            poly = [
                (self.terrain_x[i],   self.terrain_y[i]),
                (self.terrain_x[i+1], self.terrain_y[i+1])
                ]
            self.fd_edge.shape.vertices=poly
            t = self.world.CreateStaticBody(
                fixtures = self.fd_edge,
                userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [ (poly[1][0], 0), (poly[0][0], 0) ]
            self.terrain_poly.append( (poly, color) )
        self.terrain.reverse()

    def _generate_clouds(self):
        # Sorry for the clouds, couldn&#39;t resist
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_walker(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        if hasattr(self.walker_body, &#34;old_morphology&#34;) and self.walker_body.old_morphology:
            init_y = TERRAIN_HEIGHT + 2 * self.walker_body.LEG_H
        else:
            init_y = TERRAIN_HEIGHT + self.walker_body.AGENT_CENTER_HEIGHT

        self.walker_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gym.core.Env</li>
<li>gym.utils.ezpickle.EzPickle</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Override close in your subclass to perform any necessary cleanup.</p>
<p>Environments will automatically close() themselves when
garbage collected or when the program exits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._destroy()
    if self.viewer is not None:
        self.viewer.close()
        self.viewer = None</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.create_terrain_fixtures"><code class="name flex">
<span>def <span class="ident">create_terrain_fixtures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create fixtures used to generate terrain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_terrain_fixtures(self):
    &#39;&#39;&#39;
        Create fixtures used to generate terrain.
    &#39;&#39;&#39;
    self.fd_polygon = fixtureDef(
        shape=polygonShape(vertices=
                           [(0, 0),
                            (1, 0),
                            (1, -1),
                            (0, -1)]),
        friction=FRICTION,
        categoryBits=0x1,
        maskBits=0xFFFF
    )

    self.fd_edge = fixtureDef(
        shape=edgeShape(vertices=
                        [(0, 0),
                         (1, 1)]),
        friction=FRICTION,
        categoryBits=0x1,
        maskBits=0xFFFF
    )

    # Init default hexagon fixture and shape, used only for Hexagon Tracks
    self.fd_default_hexagon = fixtureDef(
        shape=polygonShape(vertices=
                           [(0, 0),
                            (1, 0),
                            (1, -1),
                            (0, -1)]),
        friction=FRICTION,
        categoryBits=0x1,
        maskBits=0xFFFF
    )
    self.default_hexagon = [(-0.5, 0), (-0.5, 0.25), (-0.25, 0.5), (0.25, 0.5), (0.5, 0.25), (0.5, 0)]</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.generate_game"><code class="name flex">
<span>def <span class="ident">generate_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the task (i.e. terrain + embodiment).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_game(self):
    &#39;&#39;&#39;
        Generate the task (i.e. terrain + embodiment).
    &#39;&#39;&#39;
    self._generate_terrain()
    self._generate_clouds()
    self._generate_walker()</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, mode='human', draw_lidars=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the environment.</p>
<p>The set of supported modes varies per environment. (And some
environments do not support rendering at all.) By convention,
if mode is:</p>
<ul>
<li>human: render to the current display or terminal and
return nothing. Usually for human consumption.</li>
<li>rgb_array: Return an numpy.ndarray with shape (x, y, 3),
representing RGB values for an x-by-y pixel image, suitable
for turning into a video.</li>
<li>ansi: Return a string (str) or StringIO.StringIO containing a
terminal-style text representation. The text can include newlines
and ANSI escape sequences (e.g. for colors).</li>
</ul>
<h2 id="note">Note</h2>
<p>Make sure that your class's metadata 'render.modes' key includes
the list of supported modes. It's recommended to call super()
in implementations to use the functionality of this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>the mode to render with</dd>
</dl>
<p>Example:</p>
<p>class MyEnv(Env):
metadata = {'render.modes': ['human', 'rgb_array']}</p>
<pre><code>def render(self, mode='human'):
    if mode == 'rgb_array':
        return np.array(...) # return RGB frame suitable for video
    elif mode == 'human':
        ... # pop up a window and render
    else:
        super(MyEnv, self).render(mode=mode) # just raise an exception
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, mode=&#39;human&#39;, draw_lidars=True):
    #self.scroll = 1
    from gym.envs.classic_control import rendering
    if self.viewer is None:
        self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
    self.viewer.set_bounds(self.scroll, RENDERING_VIEWER_W/SCALE + self.scroll, 0, RENDERING_VIEWER_H/SCALE)

    self.viewer.draw_polygon( [
        (self.scroll,                  0),
        (self.scroll+RENDERING_VIEWER_W/SCALE, 0),
        (self.scroll+RENDERING_VIEWER_W/SCALE, RENDERING_VIEWER_H/SCALE),
        (self.scroll,                  RENDERING_VIEWER_H/SCALE),
        ], color=(0.9, 0.9, 1.0) )
    for poly,x1,x2 in self.cloud_poly:
        if x2 &lt; self.scroll/2: continue
        if x1 &gt; self.scroll/2 + RENDERING_VIEWER_W/SCALE: continue
        self.viewer.draw_polygon( [(p[0]+self.scroll/2, p[1]) for p in poly], color=(1,1,1))
    for poly, color in self.terrain_poly:
        if poly[1][0] &lt; self.scroll: continue
        if poly[0][0] &gt; self.scroll + RENDERING_VIEWER_W/SCALE: continue
        self.viewer.draw_polygon(poly, color=color)

    for obj in self.drawlist:
        for f in obj.fixtures:
            trans = f.body.transform
            if type(f.shape) is circleShape:
                t = rendering.Transform(translation=trans*f.shape.pos)
                self.viewer.draw_circle(f.shape.radius, 30, color=obj.color1).add_attr(t)
                self.viewer.draw_circle(f.shape.radius, 30, color=obj.color2, filled=False, linewidth=2).add_attr(t)
            else:
                path = [trans*v for v in f.shape.vertices]
                self.viewer.draw_polygon(path, color=obj.color1)
                path.append(path[0])
                self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

    # Draw lidars
    if draw_lidars:
        for i in range(len(self.lidar)):
            l = self.lidar[i]
            self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

    flagy1 = TERRAIN_HEIGHT
    flagy2 = flagy1 + 50/SCALE
    x = TERRAIN_STEP*3
    self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
    f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
    self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
    self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

    return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the environment to an initial state and returns an initial
observation.</p>
<p>Note that this function should not reset the environment's random
number generator(s); random variables in the environment's state should
be sampled independently between multiple calls to <code>reset()</code>. In other
words, each call of <code>reset()</code> should yield an environment suitable for
a new episode, independent of previous episodes.</p>
<h2 id="returns">Returns</h2>
<p>observation (object): the initial observation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self._destroy()
    self.world.contactListener_bug_workaround = ContactDetector(self)
    self.world.contactListener = self.world.contactListener_bug_workaround
    self.head_contact = False
    self.prev_shaping = None
    self.scroll = 0.0
    self.lidar_render = 0

    self.generate_game()

    self.drawlist = self.terrain + self.walker_body.get_elements_to_render()

    self.lidar = [LidarCallback(self.walker_body.reference_head_object.fixtures[0].filterData.maskBits)
                  for _ in range(NB_LIDAR)]
    self.episodic_reward = 0

    return self.step(np.array([0] * self.action_space.shape[0]))[0]</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the seed for this env's random number generator(s).</p>
<h2 id="note">Note</h2>
<p>Some environments use multiple pseudorandom number generators.
We want to capture all such seeds used in order to ensure that
there aren't accidental correlations between multiple generators.</p>
<h2 id="returns">Returns</h2>
<p>list<bigint>: Returns the list of seeds used in this env's random
number generators. The first value in the list should be the
"main" seed, or the value which a reproducer should pass to
'seed'. Often, the main seed equals the provided 'seed', but
this won't be true if seed=None, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.set_environment"><code class="name flex">
<span>def <span class="ident">set_environment</span></span>(<span>self, roughness=None, stump_height=None, stump_width=None, stump_rot=None, obstacle_spacing=None, poly_shape=None, stump_seq=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the parameters controlling the PCG algorithm to generate a task.
Call this method before <code>reset()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>roughness</code></strong></dt>
<dd>Input vector controlling the CPPN</dd>
<dt><strong><code>stump_height</code></strong></dt>
<dd>Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled</dd>
<dt><strong><code>stump_width</code></strong></dt>
<dd>Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled</dd>
<dt><strong><code>stump_rot</code></strong></dt>
<dd>Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled</dd>
<dt><strong><code>obstacle_spacing</code></strong></dt>
<dd>Spacing between stumps</dd>
<dt><strong><code>poly_shape</code></strong></dt>
<dd>Shape of polygon stumps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_environment(self, roughness=None, stump_height=None, stump_width=None, stump_rot=None,
                    obstacle_spacing=None, poly_shape=None, stump_seq=None):
    &#39;&#39;&#39;
        Set the parameters controlling the PCG algorithm to generate a task.
        Call this method before `reset()`.

        Args:
            roughness: Input vector controlling the CPPN
            stump_height: Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled
            stump_width: Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled
            stump_rot: Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled
            obstacle_spacing: Spacing between stumps
            poly_shape: Shape of polygon stumps
    &#39;&#39;&#39;
    self.roughness = roughness if roughness else 0
    self.obstacle_spacing = max(0.01, obstacle_spacing) if obstacle_spacing is not None else 8.0
    self.stump_height = [stump_height, 0.1] if stump_height is not None else None
    self.stump_width = stump_width
    self.stump_rot = stump_rot
    self.hexa_shape = poly_shape
    self.stump_seq = stump_seq
    if poly_shape is not None:
        self.hexa_shape = np.interp(poly_shape,[0,4],[0,4]).tolist()
        assert(len(poly_shape) == 12)
        self.hexa_shape = self.hexa_shape[0:12]</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Run one timestep of the environment's dynamics. When end of
episode is reached, you are responsible for calling <code>reset()</code>
to reset this environment's state.</p>
<p>Accepts an action and returns a tuple (observation, reward, done, info).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>object</code></dt>
<dd>an action provided by the agent</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>observation (object): agent's observation of the current environment
reward (float) : amount of reward returned after previous action
done (bool): whether the episode has ended, in which case further step() calls will return undefined results
info (dict): contains auxiliary diagnostic information (helpful for debugging, and sometimes learning)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, action):
    self.walker_body.activate_motors(action)

    self.world.Step(1.0/FPS, 6*30, 2*30)

    head = self.walker_body.reference_head_object
    pos = head.position
    vel = head.linearVelocity

    for i in range(NB_LIDAR):
        self.lidar[i].fraction = 1.0
        self.lidar[i].p1 = pos
        self.lidar[i].p2 = (
            pos[0] + math.sin(1.5*i/NB_LIDAR)*LIDAR_RANGE,
            pos[1] - math.cos(1.5*i/NB_LIDAR)*LIDAR_RANGE)
        self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
    state = [
        head.angle,        # Normal angles up to 0.5 here, but sure more is possible.
        2.0*head.angularVelocity/FPS,
        0.3*vel.x*(VIEWPORT_W/SCALE)/FPS,  # Normalized to get -1..1 range
        0.3*vel.y*(VIEWPORT_H/SCALE)/FPS]

    # add leg-related state
    state.extend(self.walker_body.get_motors_state())

    if self.walker_body.body_type == BodyTypesEnum.CLIMBER:
        state.extend(self.walker_body.get_sensors_state())

    state += [l.fraction for l in self.lidar]

    self.scroll = pos.x - RENDERING_VIEWER_W/SCALE/5

    shaping  = 130*pos[0]/SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
    if not (hasattr(self.walker_body, &#34;remove_reward_on_head_angle&#34;) and self.walker_body.remove_reward_on_head_angle):
        shaping -= 5.0*abs(state[0])  # keep head straight, other than that and falling, any behavior is unpunished

    reward = 0
    if self.prev_shaping is not None:
        reward = shaping - self.prev_shaping
    self.prev_shaping = shaping

    for a in action:
        reward -= self.walker_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1) # 80 =&gt; Original torque
        # normalized to about -50.0 using heuristic, more optimal agent should spend less

    done = False
    if self.head_contact or pos[0] &lt; 0:
        reward = -100
        done   = True
    if pos[0] &gt; (TERRAIN_LENGTH-TERRAIN_END)*TERRAIN_STEP:
        done   = True
    self.episodic_reward += reward
    return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="http://developmentalsystems.org/TeachMyAgent/doc/">
<img src="https://github.com/flowersteam/TeachMyAgent/blob/gh-pages/images/home/head_image.png?raw=true" style="display: block; margin: 1em auto">
</a>
<a href="http://developmentalsystems.org/TeachMyAgent/doc/">Home</a> | <a href="http://developmentalsystems.org/TeachMyAgent/">Website</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TeachMyAgent.environments.envs" href="index.html">TeachMyAgent.environments.envs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.Rotate2D" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.Rotate2D">Rotate2D</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector">ContactDetector</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.BeginContact" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.BeginContact">BeginContact</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.EndContact" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ContactDetector.EndContact">EndContact</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback">LidarCallback</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback.ReportFixture" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.LidarCallback.ReportFixture">ReportFixture</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks">ParametricContinuousStumpTracks</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.close" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.close">close</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.create_terrain_fixtures" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.create_terrain_fixtures">create_terrain_fixtures</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.generate_game" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.generate_game">generate_game</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.metadata" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.metadata">metadata</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.render" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.render">render</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.reset" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.reset">reset</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.seed" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.seed">seed</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.set_environment" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.set_environment">set_environment</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.step" href="#TeachMyAgent.environments.envs.parametric_continuous_stump_tracks.ParametricContinuousStumpTracks.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>